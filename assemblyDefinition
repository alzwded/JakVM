.stack 4M                   ; total addressable memory = 16M
                            ; some are reserved for ports
                            ; first instruction is @0
                            ; ports begin @FFFFFF and go down
                            ; stack begins after ports end and goes down
                            ; @HI_STACK there is the user stack and 
                            ;           it shrinks
                            ; @LOW_STACK there is the procedure call stack
                            ;            and it grows
                            ; @LOW_STACK-1 the data segment begins and goes
                            ;              down

.data
hex1    h2      0xDEAD
hex2    h2      0xBEEF
hex4    h4      0xAB2ACADA
addr    addr    ABCDEF
nb      h2      0d12345
str     string  'Mary had a little lamb'
array   a1      A, B, C, D
pixel1_1    addr    FF4A00  ; in theory. Some addresses are reserved for
                            ; ports, duh

.pre
keep    h1                  ; all are initialized to 0 starting from
                            ; address 0
stuff   a1      64          ; 64 bytes
idx     h2                  ; one 16bit halfword, init'd to 0
stuff2  a4      16          ; 64 bytes

.code
begin:
    mov2    AH, 0
    mov2    AL, 0
    mov2    EH, hex1
    mov2    EL, hex2
    add4    AX, EX
    add4    EX, 1
    sto4    AX, pixel1_1
    jmp     begin:
    jmp     @0080C0
    jmp     -0d13
    jmp     -0xD
    jmp     -0b1101
.include 'toolkit.a'    ; literally include code from another assembly here
                        ; however, data definitions are appended and 
                        ; some directives can be ignored
special:
    nop
    nop
    nop

======================================================================

assembler components:

scout module:
    read file.a:
        read directives -> store in directives[]
        read .data      -> store in data map
        read .code      -> store in code map
        handle includes -> reparse

        enum directive { dirStackSize, dirOther };
        struct data_entry {
            data_type type;
            ??? data_val;
            unsigned char[] bytes();
        }
        enum param_type { address, imediate, register }
        struct param {
            param_type type;
            string val;
            unsigned char[] bytes();
        }
        struct instruction { string mnemonic; param param1, param2; }
            could be a class with a factory constructor like
            instruction InstructionFactory::Spawn(char* mnemonic, char* param1, char* param2);
        struct raw_file {
            map<directive, string> directives;
            map<string, data_entry> data;
            vector<instruction> code;
        }
        so we need c++
    assemble
        write out ~16MB file with code
        what is written out per each instruction is handled by the file
          generated by generator::generateAsmFile()
        so roughly something like:
            1. write out data at data segment
            2. inject actual data from data segment and labels as addresses
               into instruction parameters
            3. for_each(raw_file.code -> i)
                   fout << generatedFile::toBinary(i->mnemonic.c_str, i->param1.bytes, i->param2.bytes);
            ?. somewhere inbetween convert labels to addresses or relative
               addresses or whatnots

    utilities:
        string getNextToken(iStream)
        isDirective(string)

command line:
jakasm file                     reads file.a writes file.b
jakasm infile.a outfile.b       explicit
